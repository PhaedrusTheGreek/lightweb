A. Missing Pieces â€” Cannot Start Coding Without These
1. No Database Schema
The PRD states content lives in PostgreSQL but provides zero table design. We need to know how AP objects, activities, conversations, messages, followers/following, and media metadata are stored. Without this, we can't build the AP engine, the feed, or chat. This is the single biggest blocker.

2. No Client REST API Specification
Section 6.1 defines AP federation endpoints, but there are no client-facing API endpoints. How does the mobile app fetch the feed? How does it send an LLM request? What's the response format? There's no GET /api/feed, POST /api/input, GET /api/conversations/:id, etc. The entire client-server contract is missing.

3. WebSocket Protocol Undefined
Chat depends on WebSockets for real-time delivery, typing indicators, presence, and read receipts. But there's no message format, no authentication handshake, no channel subscription model, no event types. Line 271 just says "Attached to Next.js HTTP server" â€” that's not buildable.

4. LLM Response Schema
Line 586 mentions { replyText, actions[] } but that's the entire spec for the most critical integration in the system. What's the actual JSON schema? How are multiple actions ordered? What happens on partial failure (action 1 succeeds, action 2 fails)? How does the LLM signal it needs clarification vs. it's dispatching an action? How is the system prompt actually assembled?

5. Feed Assembly Logic
How is the home feed constructed? Is it purely reverse-chronological? How are heterogeneous card types (Note, ChatMessage, Follow notification, friend request) merged into one stream? Is it built from the AP inbox? From a denormalized feed table? From Redis? Pagination strategy?

6. Container Provisioning Flow
Section 5.4 says each user gets a dedicated container with their own domain. Section 7.7 says accounts are "auto-provisioned from SSO identity on first login." But who creates the container and assigns the domain before the user can log in? There's an entire orchestration layer (signup -> domain allocation -> container spin-up -> DNS -> first auth) that isn't designed.

7. Media Upload Pipeline
S3/R2 is mentioned for media storage but there's no upload flow. Pre-signed URLs? Proxy through the API? Size limits? Allowed formats? How does the client attach an image to a Note? This blocks content creation.

8. MLS Library / Integration Strategy
MLS (RFC 9420) is a dense protocol. The PRD should specify which library will be used (e.g., openmls via WASM? A Node native binding? A pure-JS implementation?). The Welcome message delivery over AP, key package distribution, and epoch synchronization across federated servers are all non-trivial and unspecified.

9. Error / Degradation Strategy
What happens when:

The LLM API is down (the entire UI becomes non-functional in LLM mode)
A federated server is unreachable (retry policy? dead letter queue?)
Redis crashes (feed cache lost â€” rebuild strategy?)
The config JSON file is corrupted on disk
The system has zero fallback design. For an app where the LLM is the only input method, LLM downtime is catastrophic.

10. Config Registry Versioning / Migration
The config is a JSON file loaded at startup. When the schema changes between releases (new keys, renamed paths, restructured sections), there's no migration strategy. This will bite immediately after the first deployment.

B. Inconsistencies and Errors
1. Product is both in-scope and out-of-scope
Section 4.2 lists "ECommerce tooling" as out of scope. But Section 9.3 includes Product as a v1 type, and Section 9.8 gives it Purchase as an available action. Pick one â€” either Product/Purchase ships in v1 or it doesn't.

2. Audio/Video types exist but media hosting is out of scope
Section 4.2 says "Video hosting / media" is out of scope. Yet Audio and Video are v1 types (Â§9.7) with Play actions and streamUrl metadata. Where does this content come from? These types are meaningless without a hosting or linking strategy.

3. user.profile.* config paths don't exist in the registry
Skills at Â§12.2 reference user.profile.display_name, user.profile.bio, user.profile.avatar_url. But the Config Registry structure at Â§11.3 has no user section at all. Either the config structure is incomplete or the skill sandboxes reference wrong paths.

4. registrations_open makes no sense in single-user model
Section 11.3 has "registrations_open": true in the config. But Â§5.4 says each server has exactly one user. You can't open registrations on a single-user server.

5. The [Send] button contradicts "No Buttons"
Multiple diagrams (line 493, line 799) show a [Send] button in the input bar, directly contradicting the core design philosophy at Â§1.4: "No navigation tabs, no settings screens, no action menus." Is send-on-Enter the intended interaction? This needs clarification because it affects the fundamental input bar component.

6. Roadmap sequencing issue
Phase 7 "Object Model + Reviews" is at weeks 16-19, but LightwebObject is needed by Phase 1 (federation needs typed objects) and Phase 3 (ChatMessage is a LightwebObject). The object model should be Phase 0-1, not Phase 7.

7. user.preferences.playback.* and user.preferences.payment.* don't exist either
Extension manifests at Â§9.10 reference user.preferences.playback.device, user.preferences.playback.quality, and user.preferences.payment.defaultMethod. None of these paths exist in the Config Registry structure.

C. Superfluous / Micromanagement â€” Will Impede Building
1. Post-v1 items are scattered everywhere and should be extracted
TrustRequest, TrustGrant, controlled accounts, video chat, user-defined skills, blockchain review counts â€” these appear dozens of times across every section. They add noise and ambiguity about what's actually in scope. Recommendation: Move all post-v1 content to a single appendix. The v1 PRD should describe only what we're building.

2. Philosophy sections are repeated 4+ times
The "allowlist, never deny" concept appears at Â§1.4, Â§8.1, Â§10.1, and Â§12.1. "Config is the single source of truth" appears at Â§11.1, Â§11.4, and Â§12.5. Once is sufficient. Repetition adds ~300 lines of noise.

3. The skill file system is over-engineered for 20 boolean toggles
The entire skill architecture (Â§12.2) â€” markdown files with extends, Purpose, Sandbox, Parameters, Behaviour sections, a parent skill, a skill loader â€” is a lot of machinery for what amounts to 20 config setters. Most of these are set config.path.X = value. A simpler approach: a single action handler with a permission map ({ "set-read-receipts": { path: "messaging.rcs.read_receipts", type: "boolean" } }). The LLM doesn't need a markdown file to understand "set a boolean." This abstraction is premature and will slow down Phase 0.

4. Extension manifest format is premature for 6 hardcoded types
Section 9.10 specifies a full manifest system with llmContext.intentExamples, parameterPrompts, trustRequirements, registryDefaults â€” all for types that are known at compile time. For v1, these types can simply be code. The manifest system is a v2 concern for when types actually become extensible.

5. Specific indicator emoji (ðŸ”“ðŸ”’ðŸ“¡) and animation durations (300ms)
These are implementation details, not product requirements. Specifying animation_duration_ms: 300 in the config registry and exact emoji for encryption indicators is the kind of detail that should be decided during UI implementation, not locked into the PRD.

6. Excessive ASCII diagrams showing the same layout
The two-pane layout is diagrammed at Â§7.1, Â§7.3, Â§7.4 (twice â€” tablet AND mobile), and Â§7.6. One canonical diagram is enough. The rest are ~150 lines of duplicated visual explanation.

7. The entire Â§9.2 conformance table
The 40-row table mapping every AP/AS type to "implemented / not implemented" (Â§9.2) is reference material, not a design document. The implemented types are already listed in Â§6.2 and Â§9.3. The "â€”" rows (types we're NOT implementing) add nothing and will never be consulted during development.

Summary â€” What I'd Fix Before Starting
Must have (blocks coding):

Database schema design (tables, relationships, indexes)
Client REST API specification (endpoints, request/response formats)
WebSocket protocol definition
LLM request/response contract
Feed assembly strategy
Container provisioning / signup flow
Resolve Product/Audio/Video scope contradictions
Add user.profile and user.preferences to config registry structure
Should have (will cause rework without):
9. Media upload flow
10. MLS library choice and integration pattern
11. Error/degradation handling strategy
12. Config migration strategy

Clean up (will cause confusion during implementation):
13. Extract all post-v1 content to an appendix
14. Remove duplicated philosophy sections
15. Simplify the skill system to a config-path permission map
16. Fix the roadmap ordering (object model must come before federation)

The core architecture is sound â€” single-process Next.js, single-user-per-server, AP federation, config registry as source of truth. But the PRD is heavily specified on concepts and under-specified on interfaces. We have detailed explanations of why the system works this way but not enough detail on what data crosses which boundary in what format â€” which is exactly what you need to start writing code.